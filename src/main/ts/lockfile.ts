import lf from '@yarnpkg/lockfile'
import { SpawnSyncReturns } from 'child_process'
import fs from 'fs-extra'
import { keyBy } from 'lodash-es'
import sv from 'semver'

import {
  TAuditEntry,
  TAuditReport,
  TContext,
  TLockfileObject
} from './ifaces'

import {
  attempt,
  formatFlags,
  getNpm,
  getYarn,
  invoke,
  mapFlags,
  parseYaml,
  formatYaml
} from './util'

export const getLockfileType = (lockfile: string): string | null => {
  if (lockfile.match(/yarn lockfile v1/)) {
    return 'yarn1'
  }

  if (lockfile.match(/__metadata/)) {
    return 'yarn2'
  }

  return null
}

export const _read = (name: string): TLockfileObject => {
  const raw = fs.readFileSync(name, 'utf-8')
  const lockfileType = getLockfileType(raw)

  if (lockfileType === null) {
    throw new Error('Unsupported lockfile format')
  }

  if (lockfileType === 'yarn2') {
    const data = parseYaml(raw)
    delete data.__metadata

    return Object.entries(data).reduce<Record<string, any>>((m, [key, value]: [string, any]) => {
      key.replaceAll('@npm:', '@').split(', ').forEach(k => {
        m[k] = value
      })
      return m
    }, {})
  }

  const data = lf.parse(raw)

  if (data.type !== 'success') {
    throw new Error('Merge conflict in yarn lockfile, aborting')
  }

  return data.object
}

export const format = (lockfile: TLockfileObject, lockfileType?: string): string => {
  if (lockfileType === 'yarn2'){
    const keymap = Object.entries(lockfile).reduce<Record<string, any>>((m, [k, {resolution}]) => {
      const entry = m[resolution] || (m[resolution] = [])
      entry.push(k.replace(/(?<!^)@/, '@npm:'))

      return m
    }, {})

    const data = Object.values(lockfile).reduce<Record<string, any>>((m, value) => {
      const key = keymap[value.resolution].join(', ')
      m[key] = value

      return m
    }, {
      __metadata: {
        version: 5,
        cacheKey: 8
      }
    })

    return `# This file is generated by running "yarn install" inside your project.
# Manual changes might be lost - proceed with caution!

${formatYaml(data, {quotingType: '"', flowLevel: -1, lineWidth: -1}).replace(/\n"/g, '\n\n"')} 
`
  }

  return lf.stringify(lockfile)
}

export const _write = (name: string, lockfile: TLockfileObject): void => {
  fs.writeFileSync(name, format(lockfile))
}

/**
 * Pulled up from https://github.com/hfour/yarn-audit-fix-ng/blob/main/src/index.ts
 */
export const _patch = (
  lockfile: TLockfileObject,
  report: TAuditReport,
  { flags }: TContext,
): TLockfileObject => {
  if (Object.keys(report).length === 0) {
    !flags.silent && console.log('Audit check found no issues')
    return lockfile
  }

  const upgraded: string[] = []

  for (const depSpec of Object.keys(lockfile)) {
    const [pkgName, desiredRange] = depSpec.split('@')
    const pkgAudit = report[pkgName]
    if (!pkgAudit) continue
    const pkgSpec = lockfile[depSpec]
    if (sv.satisfies(pkgSpec.version, pkgAudit.vulnerable_versions)) {
      const fix = sv.minVersion(pkgAudit.patched_versions)?.format()
      if (fix === undefined) {
        console.error(
          "Can't find satisfactory version for",
          pkgAudit.module_name,
          pkgAudit.patched_versions,
        )
        continue
      }
      if (!sv.satisfies(fix, desiredRange) && !flags.force) {
        console.error(
          "Can't find patched version that satisfies",
          depSpec,
          'in',
          pkgAudit.patched_versions,
        )
        continue
      }
      upgraded.push(`${pkgName}@${fix}`)
      pkgSpec.version = fix
      pkgSpec.dependencies = {}
      pkgSpec.integrity = ''
      pkgSpec.resolved = ''

      // v2
      pkgSpec.resolution = `${pkgName}@npm:${fix}`
      delete pkgSpec.checksum
    }
  }

  !flags.silent &&
    console.log(
      'Upgraded deps:',
      upgraded.length > 0 ? upgraded.join(', ') : '<none>',
    )

  return lockfile
}

export const _audit = ({ flags, temp }: TContext): TAuditReport => {
  const cmd = flags.reporter === 'npm' ? getNpm(flags['npm-path']) : getYarn()
  const mapping = {
    'audit-level': 'level',
    only: {
      key: 'groups',
      values: {
        prod: 'dependencies',
        dev: 'devDependencies',
      },
    },
  }
  const _flags = formatFlags(
    mapFlags(flags, mapping),
    'groups',
    'verbose',
    'level',
  )
  const report = invoke(
    cmd,
    ['audit', '--json', ..._flags],
    temp,
    !!flags.silent,
    false,
    true,
  )

  return _parseAuditJsonReport(report)
}

export const _parseAuditJsonReport = (
  data: string | SpawnSyncReturns<Buffer>,
): TAuditReport =>
  keyBy(
    data
      .toString()
      .split('\n')
      .map((item) => attempt(() => JSON.parse(item)) as TAuditEntry)
      .map((item) => item?.data?.advisory)
      .filter((item) => item !== undefined)
      .map((item) => ({
        module_name: item.module_name,
        vulnerable_versions: item.vulnerable_versions,
        patched_versions: item.patched_versions,
      })),
    (item) => item.module_name,
  )

// FIXME Jest cannot mock esm yet
// https://github.com/facebook/jest/commit/90d6908492d164392ce8429923e7f0fa17946d2d
export const _internal = {
  _read,
  _audit,
  _patch,
  _parseAuditJsonReport,
  _write,
}

export const read: typeof _read = (...args) => _internal._read(...args)
export const audit: typeof _audit = (...args) => _internal._audit(...args)
export const patch: typeof _patch = (...args) => _internal._patch(...args)
export const write: typeof _write = (...args) => _internal._write(...args)
export const parseAuditJsonReport: typeof _parseAuditJsonReport = (...args) =>
  _internal._parseAuditJsonReport(...args)
